-->The akka-cluster module provides a very simple cluster membership service which lays the foundations for all
   higher-level cluster features of Akka.A cluster is made up from collaborating actor systems called member nodes.
   It is important to understand that cluster membership happens at the level of actor systems,not individual actors.
   Nevertheless it can be used to build high-level cluster features which apply to individual actors


//From Daniel
--> Clustering allows to build distributed application=-

=====From Lightbend================
--> akka clusters provide a way to distribute akka actors across a cluster of nodes
--> This distribution allows us to overcome many limitations of traditional systems:
--> With an akka cluster we can:
    Distribute large tasks across a cluster of machines
    Reduce the traffic to an overloaded database
    Share critical data across nodes without additional infrastructure
    And more!

--> Single machine, dealing with large workloads, we want to improve the performance by adding
    more CPU's, more memory etc (Vertical Scalability)

--> Akka Cluster Aware Routers:
    Allows our work to be distributed across cluster
    a large task can be broken into smaller tasks, and each task can be routed to an instance
    of our application on another machine
    we are not limited to the size of a single machine. We can add more machines to improve the
    performance (Horizontal Scalability)

--> Databases:
    Many applications leverage the database(single instance, it's a bottleneck) heavily
    Multiple calls are made to db for incomming requests
    locks and transactions ensure consistency , but create contention
    As application scales up, contention becomes worse, and eventually db simply can't keep up
    Solution: Akka Cluster Sharding

--> Akka Cluster Sharding distributes Actors across the cluster
    Each Actor maintains state for a specific database identifier(probably a table)
    The Actor's in-memory state acts as a cache, eliminating the need for the database reads
    The Actor Model guarantees that the state and database are always consistent
    Separate Reads from Writes.
    Akka Cluster Sharding can be used to create a write thru cache

--> Problem: Shared Data/State
    Sometimes there is information that is critical to our system, it's needed in variety of place, all the time
    Often, its kept in db table or some cache service like redis, in this case we return to same database bottleneck
    Solution: Akka Distributed Data

--> Akka Distributed Data provides, local, replicated, in-memory data storage
    application-instance1---distributed-data ---from replication
    application-instance2---distributed-data ---from replication
    Because it is local, and in-memory, access is very fast
    It is asynchronously replicated to other nodes, ensuring all nodes have access to the data
    Replication is low-latency, ensuring fast updates across the cluster
    Means if we make update to one node, it will quickly get replicated to another node
    No additional infrastructure needed

--> Features like Cluster aware routers, Cluster Sharding and Distributed data make Akka Cluster
    very powerful.
    Many traditional systems are limited by the size of a single physical machine
    Akka cluster allows us to take advantage of hardware available on many machines
    It also allows ways to reduce or eliminate bottleneck in the system
    This allows Akka Clusters to be uniquely Scalable

===Cluster-Formation=====
    //Akka remote transports
     remote {
        artery {
          enabled = on
          transport = aeron-udp #tcp too, #tls-tcp : if encryption is required
          canonical.hostname = "localhost"
        }
      }

      akka.actor.provider = remote: allows actor system to manage actors on other nodes

--> Each instance (akka://AS@localhost:2114) of the ActorSystem that connects to the cluster is called a member, or node.
--> Each cluster member can be addressed with a combination of hostname and port.
--> A uuid is also included as a unique identifier for each type of the hostname and port.
--> Each time actor system at any hostname and port is restarted, a new uuid is generated.
--> A given hostname, port, uuid combination can only join the cluster once.
--> Joining an Akka Cluster requires an initial set of contact points, known as seed nodes.
--> Seed nodes don't need to be special in any way. Any member of a cluster can potentially act as a seed node.
--> When the node has fully joined and been accepted into the cluster, the seed nodes are no longer used.
--> Gossip protocol
--> Akka has build in support for statically configured seed-nodes
    cluster {
        seed-nodes = ["akka://MyActorSystem@localhost:2551", ""]
    }
    Other techniques such as Akka Cluster Bootstrap, it leverages available infrastructure to dynamically assign
    seed nodes.
--> The first-node in the seed list is required during cluster formation
    - When the first seed node tries to join
       If the cluster has not formed: it will form a cluster of one node.
       If the cluster has already formed: it will join the existing cluster.
    - All other nodes require an existing cluster to join.
    - Once the cluster has formed, the first node is not important

--> Seed nodes represent initial contact points for the cluster.
--> If all seed nodes were restarted/failed at the same time, there would be no way to contact any remaining nodes
    (become orphaned, they will form own cluster, no way to contact them, no seed node connected to them).
--> The remaining nodes would need to be restarted to recover.
--> Good Practice: Ensure that one ore more seed nodes remain running at all times.
--> Best Practice: Avoid static seed node configuration. User Akka Cluster Bootstrap instead.