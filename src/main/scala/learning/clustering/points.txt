-->The akka-cluster module provides a very simple cluster membership service which lays the foundations for all
   higher-level cluster features of Akka.A cluster is made up from collaborating actor systems called member nodes.
   It is important to understand that cluster membership happens at the level of actor systems,not individual actors.
   Nevertheless it can be used to build high-level cluster features which apply to individual actors


//From Daniel
--> Clustering allows to build distributed application=-

=====From Lightbend================
--> akka clusters provide a way to distribute akka actors across a cluster of nodes
--> This distribution allows us to overcome many limitations of traditional systems:
--> With an akka cluster we can:
    Distribute large tasks across a cluster of machines
    Reduce the traffic to an overloaded database
    Share critical data across nodes without additional infrastructure
    And more!

--> Single machine, dealing with large workloads, we want to improve the performance by adding
    more CPU's, more memory etc (Vertical Scalability)

--> Akka Cluster Aware Routers:
    Allows our work to be distributed across cluster
    a large task can be broken into smaller tasks, and each task can be routed to an instance
    of our application on another machine
    we are not limited to the size of a single machine. We can add more machines to improve the
    performance (Horizontal Scalability)

--> Databases:
    Many applications leverage the database(single instance, it's a bottleneck) heavily
    Multiple calls are made to db for incomming requests
    locks and transactions ensure consistency , but create contention
    As application scales up, contention becomes worse, and eventually db simply can't keep up
    Solution: Akka Cluster Sharding

--> Akka Cluster Sharding distributes Actors across the cluster
    Each Actor maintains state for a specific database identifier(probably a table)
    The Actor's in-memory state acts as a cache, eliminating the need for the database reads
    The Actor Model guarantees that the state and database are always consistent
    Separate Reads from Writes.
    Akka Cluster Sharding can be used to create a write thru cache

--> Problem: Shared Data/State
    Sometimes there is information that is critical to our system, it's needed in variety of place, all the time
    Often, its kept in db table or some cache service like redis, in this case we return to same database bottleneck
    Solution: Akka Distributed Data

--> Akka Distributed Data provides, local, replicated, in-memory data storage
    application-instance1---distributed-data ---from replication
    application-instance2---distributed-data ---from replication
    Because it is local, and in-memory, access is very fast
    It is asynchronously replicated to other nodes, ensuring all nodes have access to the data
    Replication is low-latency, ensuring fast updates across the cluster
    Means if we make update to one node, it will quickly get replicated to another node
    No additional infrastructure needed

--> Features like Cluster aware routers, Cluster Sharding and Distributed data make Akka Cluster
    very powerful.
    Many traditional systems are limited by the size of a single physical machine
    Akka cluster allows us to take advantage of hardware available on many machines
    It also allows ways to reduce or eliminate bottleneck in the system
    This allows Akka Clusters to be uniquely Scalable

========Cluster-Formation==========
    //Akka remote transports
     remote {
        artery {
          enabled = on
          transport = aeron-udp #tcp too, #tls-tcp : if encryption is required
          canonical.hostname = "localhost"
        }
      }

      akka.actor.provider = remote: allows actor system to manage actors on other nodes

--> Each instance (akka://AS@localhost:2114) of the ActorSystem that connects to the cluster is called a member, or node.
--> Each cluster member can be addressed with a combination of hostname and port.
--> A uuid is also included as a unique identifier for each type of the hostname and port.
--> Each time actor system at any hostname and port is restarted, a new uuid is generated.
--> A given hostname, port, uuid combination can only join the cluster once.
--> Joining an Akka Cluster requires an initial set of contact points, known as seed nodes.
--> Seed nodes don't need to be special in any way. Any member of a cluster can potentially act as a seed node.
--> When the node has fully joined and been accepted into the cluster, the seed nodes are no longer used.
--> Gossip protocol
--> Akka has build in support for statically configured seed-nodes
    cluster {
        seed-nodes = ["akka://MyActorSystem@localhost:2551", ""]
    }
    Other techniques such as Akka Cluster Bootstrap, it leverages available infrastructure to dynamically assign
    seed nodes.
--> The first-node in the seed list is required during cluster formation
    - When the first seed node tries to join
       If the cluster has not formed: it will form a cluster of one node.
       If the cluster has already formed: it will join the existing cluster.
    - All other nodes require an existing cluster to join.
    - Once the cluster has formed, the first node is not important

--> Seed nodes represent initial contact points for the cluster.
--> If all seed nodes were restarted/failed at the same time, there would be no way to contact any remaining nodes
    (become orphaned, they will form own cluster, no way to contact them, no seed node connected to them).
--> The remaining nodes would need to be restarted to recover.
--> Good Practice: Ensure that one ore more seed nodes remain running at all times.
--> Best Practice: Avoid static seed node configuration. User Akka Cluster Bootstrap instead.

--> In Examples, having 2 nodes for reactive bbq with sharding, so with akka cluster, all the traffice has been funneled to one actor running on
    one node, so that's why we can maintain consistency.So, benefit is we can do all of that work or lot of that work in memory, and we can just
    return that data from memory, because we know there isn't other actor running on another node somewhere that is also doing the same thing.
    At a high level what this allows us to do is have our Loyalty Accounts distributed across that cluster. Each node of the cluster will host a subset of the accounts, maintaining their data in memory. This allows us to distribute the load, but also use those accounts to maintain consistency, and minimize database reads. This is done using Akka Cluster Sharding.
    With our cluster fully working, we can retrieve data from either node, and we can update data on either node, but no matter which node we send the request through, it will direct that request to whichever node is hosting the actor for our Loyalty account. This guarantees consistency.

    Bonus Exploration: If you would like to try some more experiments, you can try using different account IDs. You should be able to observe that some account IDs always appear on node 1 while others appear on node 2. You can see where they are being created by watching the logs.

========Cluster-Management==========
--> A running cluster requires monitoring, and occasional maintenance.
--> Akka HTTP Cluster Management provides your application with a set of HTTP
	endpoints to manage the cluster.
	It can be used to:
	- Remove members from the cluster.
	- View the status and health of the cluster and it's members.
	- View information about cluster sharding distribution.